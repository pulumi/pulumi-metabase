// Code generated by Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package metabase

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resources provisions a container running Metabase on AWS ECS Fargate. By default
// the resource will run the service in the AWS Account's Default VPC unless a VPC is defined. This
// resource will also deploy the `latest` version of Metabase unless a version is supplied.
//
// You can provide specific subnets to host the Load Balancer, Database, and ECS Service, as well
// as provide a custom domain name for the service.
//
// ## Example Usage
// ### Default
//
// ```go
// package main
//
// import (
//   "github.com/pulumi/pulumi-metabase/sdk/go/metabase"
//   "github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
//   pulumi.Run(func(ctx *pulumi.Context) error {
//     metabaseService, err := metabase.NewMetabase(ctx, "metabaseService", nil)
//     if err != nil {
//       return err
//     }
//     ctx.Export("url", metabaseService.DnsName)
//     return nil
//   })
// }
// ```
// {{ /example }}
// ### Custom Domain & Networking
//
// ```go
// package main
//
// import (
//   "github.com/pulumi/pulumi-metabase/sdk/go/metabase"
//   "github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
//   pulumi.Run(func(ctx *pulumi.Context) error {
//     metabaseService, err := metabase.NewMetabase(ctx, "metabaseService", &metabase.MetabaseArgs{
//       VpcId: pulumi.String("vpc-123"),
//       Networking: &metabase.NetworkingArgs{
//         EcsSubnetIds: pulumi.StringArray{
//           pulumi.String("subnet-123"),
//           pulumi.String("subnet-456"),
//         },
//         DbSubnetIds: pulumi.StringArray{
//           pulumi.String("subnet-789"),
//           pulumi.String("subnet-abc"),
//         },
//         LbSubnetIds: pulumi.StringArray{
//           pulumi.String("subnet-def"),
//           pulumi.String("subnet-ghi"),
//         },
//       },
//       Domain: &metabase.CustomDomainArgs{
//         HostedZoneName: pulumi.String("example.com"),
//         DomainName:     pulumi.String("metabase.example.com"),
//       },
//     })
//     if err != nil {
//       return err
//     }
//     ctx.Export("url", metabaseService.DnsName)
//     return nil
//   })
// }
// ```
// {{ /example }}
type Metabase struct {
	pulumi.ResourceState

	// The DNS name for the Metabase instance.
	DnsName pulumi.StringOutput `pulumi:"dnsName"`
	// The security group id for the Metabase instance.
	SecurityGroupId pulumi.StringOutput `pulumi:"securityGroupId"`
}

// NewMetabase registers a new resource with the given unique name, arguments, and options.
func NewMetabase(ctx *pulumi.Context,
	name string, args *MetabaseArgs, opts ...pulumi.ResourceOption) (*Metabase, error) {
	if args == nil {
		args = &MetabaseArgs{}
	}

	if args.Database != nil {
		args.Database = args.Database.ToDatabasePtrOutput().ApplyT(func(v *Database) *Database { return v.Defaults() }).(DatabasePtrOutput)
	}
	var resource Metabase
	err := ctx.RegisterRemoteComponentResource("metabase:index:Metabase", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type metabaseArgs struct {
	// Optional arguments for configuring your RDS instance.
	Database *Database `pulumi:"database"`
	// Optionally provide a hosted zone and domain name for the Metabase service.
	Domain *CustomDomain `pulumi:"domain"`
	// The version of Metabase to run - used as a tag on the `metabase/metabase` Dockerhub image.
	MetabaseVersion *string `pulumi:"metabaseVersion"`
	// Optionally provide specific subnet IDs to run the different resources of Metabase.
	Networking *Networking `pulumi:"networking"`
	// The VPC to use for the Metabase service. If left blank then the default VPC will be used.
	VpcId *string `pulumi:"vpcId"`
}

// The set of arguments for constructing a Metabase resource.
type MetabaseArgs struct {
	// Optional arguments for configuring your RDS instance.
	Database DatabasePtrInput
	// Optionally provide a hosted zone and domain name for the Metabase service.
	Domain CustomDomainPtrInput
	// The version of Metabase to run - used as a tag on the `metabase/metabase` Dockerhub image.
	MetabaseVersion pulumi.StringPtrInput
	// Optionally provide specific subnet IDs to run the different resources of Metabase.
	Networking NetworkingPtrInput
	// The VPC to use for the Metabase service. If left blank then the default VPC will be used.
	VpcId pulumi.StringPtrInput
}

func (MetabaseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*metabaseArgs)(nil)).Elem()
}

type MetabaseInput interface {
	pulumi.Input

	ToMetabaseOutput() MetabaseOutput
	ToMetabaseOutputWithContext(ctx context.Context) MetabaseOutput
}

func (*Metabase) ElementType() reflect.Type {
	return reflect.TypeOf((**Metabase)(nil)).Elem()
}

func (i *Metabase) ToMetabaseOutput() MetabaseOutput {
	return i.ToMetabaseOutputWithContext(context.Background())
}

func (i *Metabase) ToMetabaseOutputWithContext(ctx context.Context) MetabaseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetabaseOutput)
}

// MetabaseArrayInput is an input type that accepts MetabaseArray and MetabaseArrayOutput values.
// You can construct a concrete instance of `MetabaseArrayInput` via:
//
//          MetabaseArray{ MetabaseArgs{...} }
type MetabaseArrayInput interface {
	pulumi.Input

	ToMetabaseArrayOutput() MetabaseArrayOutput
	ToMetabaseArrayOutputWithContext(context.Context) MetabaseArrayOutput
}

type MetabaseArray []MetabaseInput

func (MetabaseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Metabase)(nil)).Elem()
}

func (i MetabaseArray) ToMetabaseArrayOutput() MetabaseArrayOutput {
	return i.ToMetabaseArrayOutputWithContext(context.Background())
}

func (i MetabaseArray) ToMetabaseArrayOutputWithContext(ctx context.Context) MetabaseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetabaseArrayOutput)
}

// MetabaseMapInput is an input type that accepts MetabaseMap and MetabaseMapOutput values.
// You can construct a concrete instance of `MetabaseMapInput` via:
//
//          MetabaseMap{ "key": MetabaseArgs{...} }
type MetabaseMapInput interface {
	pulumi.Input

	ToMetabaseMapOutput() MetabaseMapOutput
	ToMetabaseMapOutputWithContext(context.Context) MetabaseMapOutput
}

type MetabaseMap map[string]MetabaseInput

func (MetabaseMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Metabase)(nil)).Elem()
}

func (i MetabaseMap) ToMetabaseMapOutput() MetabaseMapOutput {
	return i.ToMetabaseMapOutputWithContext(context.Background())
}

func (i MetabaseMap) ToMetabaseMapOutputWithContext(ctx context.Context) MetabaseMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetabaseMapOutput)
}

type MetabaseOutput struct{ *pulumi.OutputState }

func (MetabaseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Metabase)(nil)).Elem()
}

func (o MetabaseOutput) ToMetabaseOutput() MetabaseOutput {
	return o
}

func (o MetabaseOutput) ToMetabaseOutputWithContext(ctx context.Context) MetabaseOutput {
	return o
}

type MetabaseArrayOutput struct{ *pulumi.OutputState }

func (MetabaseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Metabase)(nil)).Elem()
}

func (o MetabaseArrayOutput) ToMetabaseArrayOutput() MetabaseArrayOutput {
	return o
}

func (o MetabaseArrayOutput) ToMetabaseArrayOutputWithContext(ctx context.Context) MetabaseArrayOutput {
	return o
}

func (o MetabaseArrayOutput) Index(i pulumi.IntInput) MetabaseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Metabase {
		return vs[0].([]*Metabase)[vs[1].(int)]
	}).(MetabaseOutput)
}

type MetabaseMapOutput struct{ *pulumi.OutputState }

func (MetabaseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Metabase)(nil)).Elem()
}

func (o MetabaseMapOutput) ToMetabaseMapOutput() MetabaseMapOutput {
	return o
}

func (o MetabaseMapOutput) ToMetabaseMapOutputWithContext(ctx context.Context) MetabaseMapOutput {
	return o
}

func (o MetabaseMapOutput) MapIndex(k pulumi.StringInput) MetabaseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Metabase {
		return vs[0].(map[string]*Metabase)[vs[1].(string)]
	}).(MetabaseOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*MetabaseInput)(nil)).Elem(), &Metabase{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetabaseArrayInput)(nil)).Elem(), MetabaseArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetabaseMapInput)(nil)).Elem(), MetabaseMap{})
	pulumi.RegisterOutputType(MetabaseOutput{})
	pulumi.RegisterOutputType(MetabaseArrayOutput{})
	pulumi.RegisterOutputType(MetabaseMapOutput{})
}
